# RouteCraft Vision & Contributor Practices

### Name

RouteCraft Vision Rule

### Always enabled

True

### Description

This rule encodes the RouteCraft vision, core DSL and runtime contracts, and contributor practices so that new code aligns with the intended architecture. It summarizes the current API surface from the source code and clarifies near‑term vision. Prefer real symbols and signatures from the repository. When this document and the code disagree, the code is the source of truth.

### Vision

- RouteCraft is a developer‑first automation and integration framework. You author small, focused routes in code using a fluent DSL, then run them across multiple runtimes.
- Routes are isolated units: each has a single source, a linear list of steps, and a consumer. A failing route does not stop others; each route is independently controlled via its `AbortController`.
- Multiple runtimes are supported:
  - CLI single‑run for executing route files or folders.
  - Node.js context runtime where you start/stop a `CraftContext` that manages many routes concurrently.
  - Next.js integration that embeds a single context into the app lifecycle and skips production build.
  - Future: Cloud runtimes and adapters (e.g., Vercel functions, DO App Platform), BUN/Deno ports.
- The “start” experience aims to feel like a light Docker/Docker Compose for routes: define a set of routes, start them together, inspect which routes are running, stop individual routes, and tail logs per route. CLI affordances like `craft log <routeId>` and route introspection are part of this direction.

### Core building blocks (from source)

- Context and routes
  - `CraftContext` manages route lifecycles, store, startup/shutdown hooks. See `packages/routecraft/src/context.ts`.
  - `RouteDefinition` holds `id`, `source`, `steps`, `consumer`. `DefaultRoute` executes steps and is controlled via an `AbortController`.
  - Store registry is extensible: adapters may extend `StoreRegistry` via declaration merging to type their entries.
- DSL entry points
  - `context()` → `ContextBuilder` for composing contexts, registering routes, stores, and hooks; `.build()` returns a `CraftContext`. See `packages/routecraft/src/dsl.ts` and `packages/routecraft/src/builder.ts`.
  - `craft()` → `RouteBuilder` for fluent route definitions.
  - Source and adapters shipped: `simple`, `channel`, `timer`; utilities: `log`, `noop`.
- RouteBuilder shape
  - `.from(optionsOrMain)` accepts either a source adapter/callable or `[RouteOptions, Source]`. If no options are supplied it auto‑generates an id.
  - Steps: `.process`, `.to`, `.split`, `.aggregate`, `.transform`, `.map`, `.tap`, `.filter`, `.validate`, `.enrich`.
  - `.build()` returns an array of `RouteDefinition`.
- Consumers
  - Default consumer is `SimpleConsumer`. `BatchConsumer` exists for batched processing.
- Logging
  - `logger` is available from `@routecraftjs/routecraft` and is used internally by routes and context.

### Runtimes (current state)

- CLI
  - `craft run <pathOrDir> [--exclude pattern] [--watch]` builds a context from route files or a directory and starts it. Watching restarts context on file changes. See `packages/cli/src/run.ts`.
  - `craft start <configPath> [--watch]` loads a module whose default export is a `CraftConfig`, constructs a `CraftContext`, registers signal handlers, and starts it. See `packages/cli/src/start.ts`.
- Node.js
  - Programmatic: `context().routes(...).onStartup(...).onShutdown(...).build().start()` starts all registered routes; stop via `.stop()`.
- Next.js
  - `createRoutecraft(config)` returns a Next config wrapper. It starts exactly one `CraftContext` during non‑build phases, stores it on a global, and registers shutdown hooks. See `packages/nextjs/src/plugin.ts`.

### Example routes (ready to run)

- Hello World transform and log

```ts
import { log, craft, simple, logger } from "@routecraftjs/routecraft";

export default craft()
  .from([{ id: "hello-world" }, simple("Hello, World!")])
  .tap(log())
  .transform((body) => {
    logger.info("Transforming exchange", { body });
    return body.toUpperCase();
  })
  .to(log());
```

- Channel fan‑in/fan‑out with transform

```ts
import { channel, log, craft, simple } from "@routecraftjs/routecraft";

export default craft()
  .from([{ id: "channel-adapter-2" }, channel("my-channel-2")])
  .tap(log())
  .from([{ id: "channel-adapter-1" }, channel("my-channel-1")])
  .tap(log())
  .transform(() => "Hello, World! 2")
  .to(channel("my-channel-2"))
  .from([{ id: "simple" }, simple("Hello, World!")])
  .tap(log())
  .to(channel("my-channel-1"));
```

- Enrich adds fields to the body

```ts
import { log, craft, simple } from "@routecraftjs/routecraft";

export default craft()
  .from([{ id: "enrich-example" }, simple({ original: "Original message" })])
  .enrich(() => ({
    additional: "Additional data",
  }))
  .to(log());
```

### Adapter authoring: good vs bad

- Good
  - Expose one constructor with a minimal options object: `myAdapter(options?: Partial<MyOptions>)`.
  - Implement exactly the operation interface(s) you need: Source → `subscribe(context, handler, abortController)`, Destination → `send(exchange)`, Processor → `process(exchange)`.
  - Prefer small, composable adapters; keep side effects contained.
  - Leverage `CraftContext` store for shared state; declare and document your store keys by extending `StoreRegistry`.
  - Provide clear `adapterId` and structured logs using `logger`.
- Bad
  - Multiple entry points or chainy, service‑specific verbs in the public DSL.
  - Hidden global state; reaching into other routes. Cross‑route comms should go through `channel(...)` or well‑defined stores.
  - Mixing many responsibilities in one adapter (source + processor + destination in a single class without good reason).
  - Tight coupling to a single runtime (e.g., assuming Next.js specifics inside a core adapter).

### Operation authoring: good vs bad

- Good
  - One function per step; accept a single options object or a single adapter instance.
  - Keep steps pure where possible: `.transform`, `.process`, `.filter`, `.tap` should not mutate external state.
  - Validate inputs at boundaries using `.validate(schema)`.
  - Use `.split`/`.aggregate` to fan out/in deterministically.
- Bad
  - Introducing new chained verbs into the public DSL (prefer options and adapters).
  - Steps that both mutate and emit side effects in unpredictable order.
  - Relying on execution order that spans across routes.

### Route authoring checklist

- Give each route a stable `id` via the first `.from([{ id }, source ])`.
- Keep each route focused on one purpose.
- Prefer pure functions for `.transform`, `.process`, `.filter`, `.tap`.
- Use `.validate` when accepting external data.
- Use `.split` and `.aggregate` to fan out and combine results.
- Use `.to` for side effects and output.
- If you need multiple flows, start another `.from` in the same builder chain or define a new builder.

### CLI developer flow

- Build: `pnpm build`
- Test: `pnpm test`
- Lint: `pnpm lint`
- Typecheck: `pnpm typecheck`
- Run example routes:
  - `pnpm craft run ./examples/hello-world.mjs`
  - `pnpm craft run ./examples --exclude "*.test.ts"`
  - `pnpm craft start ./path/to/config.ts`

### Next.js usage

- In `next.config.mjs`:

```js
import { createRoutecraft } from "@routecraftjs/nextjs";
export const withRoutecraft = createRoutecraft({ routes: myRoutes });
export default withRoutecraft({
  /* existing next config */
});
```

- Notes
  - The context starts in dev phases and is skipped during `next build`.
  - The context is stored on a global to avoid duplicate startups across HMR cycles.

### Future and vision (explicit)

- CLI UX for interactive context: list routes, stop individual routes, tail logs per route: `craft log <routeId>`.
- Cloud runtimes: adapters and wrappers to run routes as serverless handlers or long‑lived workers.
- Additional runtimes: BUN and Deno ports with compatible APIs.
- Next.js “from API” and potential “from page/router” adapters to accept inbound web requests into routes.

### Notes and uncertainties

- Some compiled docs in coverage contain truncated snippets; always confirm the source under `packages/routecraft/src/*`.
- The above “Future and vision” items are not fully implemented; they guide design and should influence new contributions.
