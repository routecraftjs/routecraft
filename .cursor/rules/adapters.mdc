---
description: "Adapter authoring: best practices, anti-patterns, and skeletons"
globs:
  [
    "examples/**/*",
    "packages/routecraft/src/adapters/**/*",
    "packages/routecraft/src/*.ts*",
    "packages/routecraft/test/**/*",
  ]
alwaysApply: false
---

### Adapters: best practices, anti-patterns, and skeletons

These rules align with RouteCraft's public DSL and adapter interfaces exported from `@routecraft/routecraft` (`Source`, `Destination`, `Processor`, `Transformer`, etc.) and the concrete adapters under `packages/routecraft/src/adapters/*`. See user‑facing docs: `apps/routecraft.dev/src/app/docs/reference/adapters/page.md`.

#### Goals

- Keep adapters minimal, focused, and composable.
- Implement only the operation interface(s) you need: `Source.subscribe`, `Destination.send`, `Processor.process`, `Transformer.transform`, etc. Adapters may implement multiple interfaces when it serves a clear purpose (e.g., log adapter implements Destination and works with `.to()` and `.tap()`).
- Use `Destination<T, R>` for `.to()`, `.enrich()`, and `.tap()`. Return the result from `send()` - it will be ignored by `.to()` (default), merged by `.enrich()` (default), or ignored by `.tap()`.
- Use `CraftContext` stores for shared state; merge options via `MergedOptions` when relevant.
- Prefer pure functions for transform-like behavior; keep side effects in `.to(...)` destinations.

#### Naming and identification

- Provide a stable `adapterId` string (e.g., "routecraft.adapter.my-adapter").
- Log with the route or exchange logger from `CraftContext`/`DefaultExchange` for consistency.

#### Options and configuration

- Use a single constructor with a minimal options object: `myAdapter(options?: Partial<MyOptions>)`.
- For adapters that need context-level config, implement `MergedOptions<T>`: expose `options` and a `mergedOptions(context)` method that reads from a typed `StoreRegistry` key.
- Extend `StoreRegistry` via declaration merging to type your store keys.

##### Options naming when source and destination differ

When an adapter can be used as both a source and a destination and has different options for each role, use this convention (see `packages/routecraft/src/adapters/direct.ts` as the reference implementation):

**Exported types (public API):**

- **Base**: `MyAdapterBaseOptions` — interface with options shared by both roles (e.g. `channelType`).
- **Source**: `MyAdapterSourceOptions extends MyAdapterBaseOptions` — interface with options only relevant when used with `.from()` (e.g. `schema`, `description`).
- **Destination**: `MyAdapterDestinationOptions = MyAdapterBaseOptions` (or extends if destination-specific options exist) — options only relevant when used with `.to()` / `.tap()`.
- **Main "Options"**: `MyAdapterOptions = MyAdapterSourceOptions | MyAdapterDestinationOptions` — the **union** type. Use this as the constructor parameter type and in all public docs/signatures.

**Internal type (not exported):**

- **Merged**: `type MyAdapterOptionsMerged = MyAdapterSourceOptions & MyAdapterDestinationOptions` — the **intersection** type. Use this for:
  - `this.options` property type
  - `StoreRegistry` store type (`Partial<MyAdapterOptionsMerged>`)
  - `mergedOptions()` return type
  - `MergedOptions<MyAdapterOptionsMerged>` interface implementation

This pattern allows the public API to accept either source or destination options (union), while internally the adapter can safely read any option property (intersection) without type errors.

**Example:**

```ts
export interface MyAdapterBaseOptions {
  timeout?: number;
}

export interface MyAdapterSourceOptions extends MyAdapterBaseOptions {
  pollInterval?: number;
  schema?: StandardSchemaV1;
}

export type MyAdapterDestinationOptions = MyAdapterBaseOptions;

// Public: union for constructor
export type MyAdapterOptions = MyAdapterSourceOptions | MyAdapterDestinationOptions;

// Internal: intersection for stored options (not exported)
type MyAdapterOptionsMerged = MyAdapterSourceOptions & MyAdapterDestinationOptions;

declare module "@routecraft/routecraft" {
  interface StoreRegistry {
    "routecraft.adapter.my.options": Partial<MyAdapterOptionsMerged>;
  }
}

export class MyAdapter<T = unknown>
  implements Source<T>, Destination<T, void>, MergedOptions<MyAdapterOptionsMerged>
{
  constructor(options: Partial<MyAdapterOptions> = {}) {
    this.options = options as Partial<MyAdapterOptionsMerged>;
  }

  public options: Partial<MyAdapterOptionsMerged>;

  mergedOptions(context: CraftContext): MyAdapterOptionsMerged {
    const store = context.getStore("routecraft.adapter.my.options") as
      | Partial<MyAdapterOptionsMerged>
      | undefined;
    return { ...store, ...this.options };
  }

  // Now this.options.schema, this.options.pollInterval, this.options.timeout all type-check
}
```

Do not name any type with "AdapterOptions" or "MergedOptions" in the suffix; reserve the simple `MyAdapterOptions` name for the union used in the public API.

#### Source adapters

- Signature: `subscribe(context, handler, abortController)` and return a Promise that resolves when the source completes or is aborted.
- Respect `abortController.signal.aborted`; add an abort listener to clean up subscriptions.
- For indefinite sources (e.g., channel subscriptions), resolve the returned Promise only on abort/unsubscribe.
- Prefer backpressure-friendly approaches; for arrays, `Promise.all` is fine for small, known batches (see `SimpleAdapter`).

#### Destination adapters

- Signature: `send(exchange): Promise<R>` where R is the result type (use `void` if no result).
- Return meaningful data when possible (e.g., database IDs, HTTP status, API responses).
- The same adapter works with both `.to()`, `.enrich()`, and `.tap()`:
  - `.to()` ignores the result by default (side-effect only) or replaces body if a value is returned
  - `.enrich()` merges the result into the body by default
  - `.tap()` receives a snapshot and runs fire-and-forget (result ignored)
- Pull context from `DefaultExchange.context` if needed for stores or loggers.

**Examples:**

```ts
// Adapter that returns void (pure side-effect)
class LogAdapter implements Destination<T, void> {
  async send(exchange: Exchange<T>): Promise<void> {
    console.log(exchange.body);
  }
}

// Adapter that returns data
class FetchAdapter implements Destination<T, FetchResult> {
  async send(exchange: Exchange<T>): Promise<FetchResult> {
    const result = await fetch(/* ... */);
    return { status: result.status, body: await result.json() };
  }
}
```

#### Processor/Transformer adapters

- Processor: `process(exchange) => Exchange` (can change headers, body, or logger).
- Transformer: `transform(body) => newBody` (pure, body-only change); the framework will write back to the exchange body.
- Keep these pure where possible; avoid external effects—use `.to(...)` instead.

##### Which to implement when

- Implement `Transformer` for reusable, pure body mapping with options.
- Implement `Processor` only if you need headers or to replace the exchange, or to package reusable read-IO with standard behavior (timeouts, retries). Otherwise prefer function processors.
- Implement `Destination<T, R>` when the adapter produces data that can be used for side-effects (`.to()`), enrichment (`.enrich()`), or fire-and-forget (`.tap()`). The return type `R` will be automatically handled based on the operation.

#### Error handling

- Catch and log external I/O failures with `context.logger.error(error, message)` or `exchange.logger.error(...)`.
- Abort only the route you own by calling `abortController.abort()` inside sources when unrecoverable.

#### Anti-patterns

- Avoid public DSL verbs inside adapters (service-specific config belongs in adapter options, not chained DSL).
- Avoid hidden side effects in sources; produce messages only. Use `.to(...)` for outputs.
- Avoid coupling via globals; use `CraftContext` stores or channels.
- Avoid mixing responsibilities (e.g., transforming and sending in one step).

#### Store usage (typed)

```ts
// Example: add adapter-scoped store entries
declare module "@routecraft/routecraft" {
  interface StoreRegistry {
    "routecraft.adapter.example.store": Map<string, unknown>;
    "routecraft.adapter.example.options": Partial<ExampleOptions>;
  }
}
```

#### Skeletons (TypeScript)

Source adapter:

```ts
import {
  type Source,
  type ExchangeHeaders,
  CraftContext,
} from "@routecraft/routecraft";

export interface MySourceOptions {
  pollIntervalMs?: number;
}

export class MySourceAdapter<T = unknown> implements Source<T> {
  readonly adapterId = "routecraft.adapter.my-source";
  constructor(private options: Partial<MySourceOptions> = {}) {}

  async subscribe(
    context: CraftContext,
    handler: (message: T, headers?: ExchangeHeaders) => Promise<void>,
    abortController: AbortController
  ): Promise<void> {
    const { pollIntervalMs = 1000 } = this.options;
    context.logger.info("Starting my-source subscription");

    return new Promise<void>((resolve) => {
      const tick = async () => {
        if (abortController.signal.aborted) return;
        try {
          const data = undefined as unknown as T; // produce or fetch your message
          await handler(data);
        } catch (error) {
          context.logger.error(error, "my-source handler failed");
          // Decide whether to abort this route
          abortController.abort();
          resolve();
          return;
        }
        setTimeout(tick, pollIntervalMs);
      };

      abortController.signal.addEventListener("abort", () => {
        context.logger.debug("my-source aborted");
        resolve();
      });

      tick();
    });
  }
}
```

Destination adapter (no return value):

```ts
import { type Destination, type Exchange } from "@routecraft/routecraft";

export interface MyDestinationOptions {
  url: string;
}

export class MyDestinationAdapter<T = unknown> implements Destination<T, void> {
  readonly adapterId = "routecraft.adapter.my-destination";
  constructor(private options: MyDestinationOptions) {}

  async send(exchange: Exchange<T>): Promise<void> {
    const { url } = this.options;
    exchange.logger.info("Sending message", { url });
    // perform side-effect using exchange.body / headers
  }
}
```

Destination adapter (with return value - works with both `.to()` and `.enrich()`):

```ts
import { type Destination, type Exchange } from "@routecraft/routecraft";

export interface MyApiOptions {
  endpoint: string;
}

export interface ApiResult {
  id: string;
  status: number;
}

export class MyApiAdapter<T = unknown> implements Destination<T, ApiResult> {
  readonly adapterId = "routecraft.adapter.my-api";
  constructor(private options: MyApiOptions) {}

  async send(exchange: Exchange<T>): Promise<ApiResult> {
    const { endpoint } = this.options;
    exchange.logger.info("Calling API", { endpoint });
    
    const response = await fetch(endpoint, {
      method: 'POST',
      body: JSON.stringify(exchange.body)
    });
    
    // Return result - available to both .to() and .enrich()
    return {
      id: response.headers.get('x-request-id'),
      status: response.status
    };
  }
}
```

Processor adapter:

```ts
import { type Processor, type Exchange } from "@routecraft/routecraft";

export class MyProcessorAdapter<T = unknown, R = T> implements Processor<T, R> {
  readonly adapterId = "routecraft.adapter.my-processor";
  async process(exchange: Exchange<T>): Promise<Exchange<R>> {
    // clone or create a new exchange with updated body/headers
    const newBody = exchange.body as unknown as R; // transform
    return { ...exchange, body: newBody };
  }
}
```

Transformer adapter (pure):

```ts
import { type Transformer } from "@routecraft/routecraft";

export class MyTransformerAdapter<T = unknown, R = T>
  implements Transformer<T, R>
{
  readonly adapterId = "routecraft.adapter.my-transformer";
  async transform(body: T): Promise<R> {
    // compute new body
    return body as unknown as R;
  }
}
```

#### Logging

- Use `context.logger` in sources and `exchange.logger` in processors/destinations.
- Prefer structured logs with a descriptive message and metadata object.

#### Testing

Refer to central testing guidance and examples:

- @.cursor/rules/testing.mdc
- @packages/routecraft/test/route.test.ts
- @packages/routecraft/test/queue.test.ts
- @packages/routecraft/test/events.test.ts
- @apps/routecraft.dev/src/app/docs/introduction/testing/page.md

#### Checklist

- Provide `adapterId`.
- Follow single-responsibility.
- Respect `AbortController` in sources.
- Keep transforms pure; side effects only in destinations.
- Use typed `StoreRegistry` and `MergedOptions` if reading from context.
