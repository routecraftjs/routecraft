---
description: "RouteCraft Contributor Practices: adapters, operations, routes, build/test"
globs: ["**/*"]
alwaysApply: false
---

## Contributor Practices

- Prefer real symbols and exact APIs from the repository. When in doubt, open the source.
- Keep routes small, composable, and isolated. If you need multiple flows, start another `.from` in the same builder or create a new builder.
- Avoid `any`: use precise types or generics. Prefer `unknown` plus narrowing when necessary.

### Adapter authoring: good vs bad

- Good
  - One constructor with a minimal options object: `myAdapter(options?: Partial<MyOptions>)`.
  - Implement the operation interface(s) needed:
    - Source: `subscribe(context, handler, abortController)`
    - Destination: `send(exchange)`
    - Processor: `process(exchange)`
  - Use `CraftContext` store for shared state. Extend `StoreRegistry` with typed keys via declaration merging.
  - Provide a clear `adapterId`, log with `logger`.
- Bad
  - Public DSL with chained, service-specific verbs.
  - Implicit globals or cross-route coupling. Use `channel(...)` or typed stores.
  - Adapters mixing unrelated responsibilities.

### Operation authoring: guidelines

- One function per step; accept a single options object or one adapter instance.
- Prefer purity for `.transform`, `.process`, `.filter`, `.tap`.
- Validate external inputs with `.validate(schema)`.
- Use `.split` and `.aggregate` for fan-out/in patterns.

### Explicit anti-patterns (avoid)

- Service-specific verbs in the public DSL
  - Bad: `api.get("/users").map(...).to(db())`
  - Better: `craft().from([ { id }, api({ method: "GET", path: "/users" })]).map(...).to(db())`
- Overloaded adapter constructors that hide behavior
  - Bad: `Api("/users")` implying GET by default
  - Better: `api({ method: "GET", path: "/users" })`
- Coupled cross-route state via globals
  - Bad: `global.currentUser = ...` inside a step
  - Better: pass data through exchanges or use `channel("name")` for inter-route messaging; use typed `StoreRegistry` keys for context-level state.
- Steps that both transform and side-effect
  - Bad: `.process(ex => { ex.body = doThing(ex.body); sendToKafka(ex); return ex; })`
  - Better: `.transform(doThing).to(kafkaProducer())`
- Hidden implicit sources/destinations
  - Bad: `.from(httpServer()).to(log())` where `httpServer` also writes to a DB
  - Better: keep sources only as sources; push side effects into `.to(...)` destinations explicitly.

### Route authoring checklist

- Set a stable `id` in the first `.from([{ id }, source ])` call.
- Keep a clear, single responsibility.
- Apply `.to` only for side effects/output destinations.

### Build and test flow

- Use pnpm workspace scripts:
  - Build: `pnpm build`
  - Test: `pnpm test`
  - Lint: `pnpm lint`
  - Typecheck: `pnpm typecheck`
- Run example routes:
  - `pnpm craft run ./examples/hello-world.mjs`
  - `pnpm craft run ./examples --exclude "*.test.ts"`
  - `pnpm craft start ./path/to/config.ts`

### Examples (references)

- Hello World: @examples/hello-world.mjs
- Enrich: @examples/enrich-example.mjs

### Documentation pointers

- Getting started: @apps/routecraft.dev/src/app/docs/introduction/installation/page.md
- Project structure: @apps/routecraft.dev/src/app/docs/introduction/project-structure/page.md
- Routes overview: @apps/routecraft.dev/src/app/docs/introduction/routes/page.md
- Testing: @apps/routecraft.dev/src/app/docs/introduction/testing/page.md
- CLI reference: @apps/routecraft.dev/src/app/docs/reference/cli/page.md

### Notes

- Source of truth lives under `packages/routecraft/src/*` and `packages/cli/src/*`.
- If compiled docs or coverage HTML differ, prefer the source files.
