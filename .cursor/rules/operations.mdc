---
description: "Operations DSL: RouteCraft step guidelines and authoring"
globs:
  [
    "packages/routecraft/src/operations/**/*",
    "packages/routecraft/src/*.ts",
    "examples/**/*",
    "packages/routecraft/test/**/*",
  ]
alwaysApply: false
---

## Operations (DSL) guidelines

This document sets guidelines for authoring RouteCraft steps. Refer to the docs under `apps/routecraft.dev/src/app/docs/reference/operations/page.md` for endâ€‘user documentation.

### RouteCraft operations (from source)

- `.from(source)`
  - Notes: A route must start with a single source. Use `[ { id }, source ]` form to set a stable route ID.

- `.process(adapter | (exchange) => exchange)`
  - Notes: Can change headers and body; return a new or modified exchange. Prefer pure transformations here; avoid side effects.

- `.transform(adapter | (body) => newBody)`
  - Notes: Body-only change. Framework writes result back to `exchange.body`.

{% badge %}implemented{% /badge %} `.map((body) => newBody)`

- Notes: Thin wrapper over transform semantics for convenience.

- `.tap(destination | (exchange) => any)`
  - Notes: Async side effect that doesn't block route. Returns values ignored. Exchange snapshotted with new ID and correlation header. Use for logging/metrics/notifications.

- `.filter(adapter | (exchange) => boolean)`
  - Notes: Rejects the exchange when predicate is false. Downstream steps will not run for rejected messages.

- `.validate(adapter | (exchange) => asserts)`
  - Notes: Throw or reject on schema violations; prefer schema libs (e.g., Zod) inside the validator.

- `.split(adapter | (exchange) => Exchange[])`
  - Notes: Fan-out into multiple exchanges; framework maintains `routecraft.split_hierarchy` headers for aggregation.

- `.aggregate(adapter | (exchanges) => Exchange)`
  - Notes: Fan-in of split groups; ensure deterministic aggregation.

- `.enrich(destination | (exchange) => data, aggregator?)`
  - Notes: Fetch/compute data and merge into body. Default aggregator merges result. Optional custom aggregator.

- `.to(destination | (exchange) => result)`
  - Notes: Send exchange to destination. If result is undefined, body unchanged. If result defined, body replaced with result.

{% badge %}wip{% /badge %} `.dedupe(options?)`
  - Notes: Stateful filter that suppresses duplicate exchanges based on a derived key. Duplicates are dropped entirely - no downstream processing, no result returned. Key is reserved immediately (single-flight), committed on route success, released on failure. Options: `{ key?: (e) => string }`. If key is omitted, derived by hashing the exchange body (sha256). Use for skipping unchanged files or preventing duplicate side effects.

{% badge %}wip{% /badge %} `.cache(options?)`
  - Notes: Wrapper operation that caches the result of the next operation. If a cached value exists, it replaces the body and the wrapped step is skipped. Only successful executions are cached. Options: `{ key?: (e) => string, ttl?: number, scope?: 'body' | 'exchange' }`. If key is omitted, derived by hashing the exchange body (sha256) before executing the wrapped step. Use for expensive operations where duplicates should return the same result.

### dedupe vs cache distinction

- **dedupe**: Duplicates should do nothing. No result, no side effects. Think "persistent filter."
- **cache**: Duplicates should return the same result. The expensive step is skipped but output is produced. Think "memoized wrapper."

### Authoring guidelines

- One function per step; prefer small, composable operations.
- Pure where possible: `.transform`, `.process`, `.filter`, `.tap`.
- Validate external inputs at boundaries with `.validate`.
- Use `.split`/`.aggregate` for fan-out/fan-in; avoid manual loops inside processors.
- Side effects belong in `.to(...)` destinations, not in processors/transformers.

### Which to use when (quick guide)

- Use `.transform` for body-only pure mapping. Metadata unchanged.
- Use `.process` to replace or reshape the entire exchange (change body and/or headers). Avoid IO here.
- Use `.to` for sending data (DB writes, HTTP emits, queues). Body replaced if destination returns data, unchanged if returns void/undefined.
- Use `.enrich` to fetch/compute extra data and merge it into body (default merge behavior).
- Use `.tap` for async fire-and-forget side effects (logging, metrics, notifications). Never blocks route.

### Header semantics

- Track operation in `routecraft.operation` header.
- Maintain correlation via `routecraft.correlation_id`.
- Preserve split lineage in `routecraft.split_hierarchy` for fan-in.
  - Timer sources set timer headers (`routecraft.timer.*`). See `packages/routecraft/src/adapters/timer.ts`.

### Testing guidance

- Prefer integration-style examples under `examples/*` to exercise step behavior end-to-end.
- For engine invariants (split/aggregate, headers, filtering), add/extend tests in `packages/routecraft/test/**/*`.
- Use deterministic inputs and assert on headers/body after each operation where meaningful.
